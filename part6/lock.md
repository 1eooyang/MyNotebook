## 死锁/信号量/管程
---

* 死锁的定义：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的
* 死锁的四个必要产生条件：
    * 1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
    * 2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
    * 3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
    * 4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
* 预防死锁的方法：
    * 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。
    * 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。
    * 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。
    * 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源

* 信号量
    * 信号量机制用于解决互斥与同步的问题。它只能被两个标准原语wait(S)和signal(S)来访问，也可以记为P操作和V操作。 
    
        P操作：申请资源，没有则排队等候。 
    
        V操作：释放资源，执行队列下一个。

        ```c
        typedef struct{
            int value;  struct process *L;
        }semaphore;
        void wait(semaphore S){ //P操作
            S.value--;//先减1
            if(S.value < 0){//再查看有没有
                add this process to S.L;//如果没有，加入等待区
                block(S.L);//并自我阻塞
            }
        }
        void signal(semaphore S){ //V操作
            S.value++;//资源数加1
            if(S.value <= 0){//释放之后仍有等待这个资源的进程
                remove a process P from S.L;//把这个进程从队列中移除
                wakeup(P);//然后唤醒这个进程
            }
        }
        ```
    * 利用信号量实现同步
    
        进程P2中y语句需要进程P1中x语句的运行结果，所有只有当x执行完后才能继续执行y。
        ```
        semaphore S = 0;//初始化信号量
        P1(){
            ...
            x;
            V(S);//告诉P2，语句x已经完成
            ...
        }
        P2(){
            ...
            P(S);//检查x是否完成，没有完成则阻塞P2直到x完成
            y;
            ...
        }
        ```
    
    * 利用信号量实现互斥

        实现两个进程对某临界资源的互斥访问。

        ```c
        semaphore S = 1;
        P1(){
            ...
            P(S);
            进程P1的临界区;
            V(S);
            ...
        }
        P2(){
            ...
            P(S);
            进程P2的临界区;
            V(S);
            ...
        }
        //两个进程先进行的那一个，先用P(S)操作加锁
        //S初值为1，先进行的进程(设为P1)的P(S)将S减1后，S==0，然后运行临界区代码访问
        //此时若P2想访问，也会先运行P(S)指令，S再减1，S==-1，陷入while循环被锁住
        //直到P1访问完成，通过V(S)使S加1，S==0，P2中的P(S)才能跳出while继续运行
        ```

        >总结： </br>
        同步问题中，如果某个行为要使用某个资源，就在那个行为前P那个资源一下。如果某个行为提供某个资源，则在那个行为后V那种资源一下。 
        上面的例子中，y要运行需要x的结果，x的结果即为资源，用S表示。x运行即为提供这种资源的行为，因此在x语句后 V一下。而y是要使用这个资源，就在y**前** P一下。 
        </br>互斥问题中，P，V操作紧紧的夹着使用互斥资源的行为即可，中间不能有其他冗余代码。

    * 利用信号量实现前驱关系

        ![](http://hi.csdn.net/attachment/201105/18/0_1305711342bG22.gif)

        设置信号量

        ![](./2016-10-16_061640.png)

        分析步骤如下 
        1. 关系分析 
        2. 整理思路 
        3. 设置信号量 
        以P3为例： 
        运行P3前需检查P1和P2是否完成，且P3是P4和P5的前驱。
        ```c
        P3(){
            P(a1);//请求访问a1和a2
            P(a2);//这两行代码运行后，说明P1和P2都已经运行完了，可以继续运行
            ...
            V(b1);//P3运行完后，设置b1和b2为可访问状态
            V(b2);//使P3的后继可以运行
        }
        //P1, P2, P4, P5的算法为：
        P1(){
            ...//没有前驱
            V(a1);//表示a1可用了
        }
        P2(){
            ...//没有前驱
            V(a2);//表示a2可用了
        }
        P4(){
            P(b1);//查询b1是否完成
            ...//没有后继
        }
        P5(){
            P(b2);//查询b2是否完成
            ...//没有后继
        }
        ```
    
* 管程:
管程是由一组数据及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。
* 管程的组成：
    * 局部于管程的共享结构数据说明
    * 对该数据结构进行操作的一组过程
    * 对局部于管程的共享数据设置初始值的语句
* 管程的基本特性
    * 局部于管程的数据只能被局部于管程内的过程访问
    * 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
    * 每次仅允许一个进程在管程内执行某个内部过程。管程相当于一个抽象类，包含几个成员变量和几个成员函数。这几个成员变量可以描述系统中的任何设备，成员函数则可以通过操作成员变量对这个设备进行操作。 
    如将成员变量初始化为某些值使这个管程表示一台打印机，进程P0进入管程后，调用成员函数来操作这台打印机。每次进入这个管程的，只有一个进程。

* 生产者消费者/读者写者/哲学家进餐问题
    * to be continued