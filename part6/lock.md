---
title: 操作系统复习
---

## 线程/进程/cpu调度

* 并发与并行的区别：并发是同时存在，并行是同时执行。并行有subtask的含义。(通俗一点讲，一只奶给两个孩子喂叫并发，两只奶给两个孩子喂叫并行，捂脸==)
* 线程池的优点：节省了创建线程的时间，限制可用线程数量(对不支持高并发的系统而言)
* 进程状态：new,running,ready,blocked/waiting,terminated.脑补进程状态图。
* fork：子进程返回0，父进程返回PID。与clone区别在于clone出的线程不共享数据。
* cpu调度可发生在四种情形中：
    * 1）running -> waiting(等待I/O)
    * 2) running -> ready(中断)
    * 3) waiting -> ready(I/O完成)
    * 4) terminated

    调度只能发生在1和4时称为非抢占
* 调度算法：
    * first come first served：非抢占
    * shortest job first：常用于 长期调度，可抢占可非抢占
    * priority scheduling：常导致starvation，解决办法是aging，即逐渐增加长时间等待的线程的优先级。
    * round-robin（轮转调度）：效率取决于时间片的大小。
    * multilevel queue scheduling（多级队列）：将就绪队列分多个队列，队列之间有绝对优先级，队列内有各自调度算法。
    * multilevel feedback queue scheduling(多级反馈队列)：在上面的基础上可使进程在队列间移动，可防止starvation。

## 死锁/信号量/管程

* busy waiting：当一个进程位于临界区内时，任何试图进入该临界区的进程都在进入代码中连续循环。
* 自旋锁：具有busy waiting特征的信号量叫自旋锁。在锁的占用时间短时自旋锁有优势，因为不进行上下文切换，常用于多处理器系统中。
* semaphore：包括value(若为负，绝对值为等待信号量的进程个数)和等待进程链表(signal从中选择进程唤醒)
* 死锁的定义：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的
* 死锁的判断：资源分配图(主要是申请边喝分配边的概念)中无环则没死锁，若每个资源类型只有一个实例，有环和死锁是互为充要条件，如果有资源类型存在不止一个实例，则有环是死锁的必要不充分条件。
* 死锁的四个必要产生条件：
    * 1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
    * 2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
    * 3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
    * 4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
* 预防死锁的方法：
    * 打破互斥条件：改造独占性资源为共享资源，大部分资源已无法改造。
    * 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。
    * 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。
    * 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源(即，要申请序号小的资源必须先释放序号大的资源)

* 信号量
    * 信号量机制用于解决互斥与同步的问题。它只能被两个标准原语wait(S)和signal(S)来访问，也可以记为P操作和V操作。 
    
        P操作：申请资源，没有则排队等候。 
    
        V操作：释放资源，执行队列下一个。

        ```c
        typedef struct{
            int value;  struct process *L;
        }semaphore;
        void wait(semaphore S){ //P操作
            S.value--;//先减1
            if(S.value < 0){//再查看有没有
                add this process to S.L;//如果没有，加入等待区
                block(S.L);//并自我阻塞
            }
        }
        void signal(semaphore S){ //V操作
            S.value++;//资源数加1
            if(S.value <= 0){//释放之后仍有等待这个资源的进程
                remove a process P from S.L;//把这个进程从队列中移除
                wakeup(P);//然后唤醒这个进程
            }
        }
        ```
    * 利用信号量实现同步
    
        进程P2中y语句需要进程P1中x语句的运行结果，所有只有当x执行完后才能继续执行y。
        ```
        semaphore S = 0;//初始化信号量
        P1(){
            ...
            x;
            V(S);//告诉P2，语句x已经完成
            ...
        }
        P2(){
            ...
            P(S);//检查x是否完成，没有完成则阻塞P2直到x完成
            y;
            ...
        }
        ```
    
    * 利用信号量实现互斥

        实现两个进程对某临界资源的互斥访问。

        ```c
        semaphore S = 1;
        P1(){
            ...
            P(S);
            进程P1的临界区;
            V(S);
            ...
        }
        P2(){
            ...
            P(S);
            进程P2的临界区;
            V(S);
            ...
        }
        //两个进程先进行的那一个，先用P(S)操作加锁
        //S初值为1，先进行的进程(设为P1)的P(S)将S减1后，S==0，然后运行临界区代码访问
        //此时若P2想访问，也会先运行P(S)指令，S再减1，S==-1，陷入while循环被锁住
        //直到P1访问完成，通过V(S)使S加1，S==0，P2中的P(S)才能跳出while继续运行
        ```

        >总结： </br>
        同步问题中，如果某个行为要使用某个资源，就在那个行为前P那个资源一下。如果某个行为提供某个资源，则在那个行为后V那种资源一下。 
        上面的例子中，y要运行需要x的结果，x的结果即为资源，用S表示。x运行即为提供这种资源的行为，因此在x语句后 V一下。而y是要使用这个资源，就在y**前** P一下。 
        </br>互斥问题中，P，V操作紧紧的夹着使用互斥资源的行为即可，中间不能有其他冗余代码。

    * 利用信号量实现前驱关系

        ![](http://hi.csdn.net/attachment/201105/18/0_1305711342bG22.gif)

        设置信号量

        ![](./2016-10-16_061640.png)

        分析步骤如下 
        1. 关系分析 
        2. 整理思路 
        3. 设置信号量 
        以P3为例： 
        运行P3前需检查P1和P2是否完成，且P3是P4和P5的前驱。
        ```c
        P3(){
            P(a1);//请求访问a1和a2
            P(a2);//这两行代码运行后，说明P1和P2都已经运行完了，可以继续运行
            ...
            V(b1);//P3运行完后，设置b1和b2为可访问状态
            V(b2);//使P3的后继可以运行
        }
        //P1, P2, P4, P5的算法为：
        P1(){
            ...//没有前驱
            V(a1);//表示a1可用了
        }
        P2(){
            ...//没有前驱
            V(a2);//表示a2可用了
        }
        P4(){
            P(b1);//查询b1是否完成
            ...//没有后继
        }
        P5(){
            P(b2);//查询b2是否完成
            ...//没有后继
        }
        ```
    
* 管程:
管程是由一组数据及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。
* 管程的组成：
    * 局部于管程的共享结构数据说明
    * 对该数据结构进行操作的一组过程
    * 对局部于管程的共享数据设置初始值的语句
* 管程的基本特性
    * 局部于管程的数据只能被局部于管程内的过程访问
    * 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
    * 每次仅允许一个进程在管程内执行某个内部过程。管程相当于一个抽象类，包含几个成员变量和几个成员函数。这几个成员变量可以描述系统中的任何设备，成员函数则可以通过操作成员变量对这个设备进行操作。 
    如将成员变量初始化为某些值使这个管程表示一台打印机，进程P0进入管程后，调用成员函数来操作这台打印机。每次进入这个管程的，只有一个进程。

* 生产者消费者/读者写者/哲学家进餐问题
    * to be continued